<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>La Ludineta</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; margin: 0; padding: 2rem; display: grid; place-items: center; min-height: 100dvh; }
    .card { width: min(720px, 92vw); padding: 1.5rem; border-radius: 1rem; box-shadow: 0 10px 30px rgba(0,0,0,.08); border: 1px solid rgba(0,0,0,.08); }
    h1 { margin: 0 0 .5rem 0; font-size: clamp(1.2rem, 3.5vw, 1.8rem); }
    .muted { opacity: .7; margin-top: .25rem; }
    button { font-size: 1rem; padding: .9rem 1.1rem; border-radius: .8rem; border: none; cursor: pointer; display: inline-flex; gap: .6rem; align-items: center; }
    button.primary { background: #0d6efd; color: white; }
    button.secondary { background: #eee; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .row { display: flex; gap: .75rem; flex-wrap: wrap; }
    .log { margin-top: 1rem; padding: .75rem; border-radius: .75rem; background: rgba(0,0,0,.04); max-height: 40vh; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: .9rem; }
    .ok { color: #0a7d2b; }
    .warn { color: #a35a00; }
    .err { color: #b00020; }
    code.kbd { background: rgba(0,0,0,.06); padding: .15rem .35rem; border-radius: .4rem; }
  </style>
</head>
<body>
  <div class="card">
    <h1>La Ludineta</h1>

    <div class="row" style="margin:1rem 0;">
      <button id="btnConnect" class="primary">üîó Conectar impresora</button>
      <button id="btnPrintImage" class="secondary" disabled>üñºÔ∏è Imprimir Imagen</button>
      <button id="btnDisconnect" class="secondary" disabled>‚èèÔ∏è Desconectar</button>
    </div>

    <div id="log" class="log" role="log" aria-live="polite"></div>
  </div>

<script>
(() => {
  const logEl = document.getElementById('log');
  const $ = sel => document.querySelector(sel);
  const btnConnect = $('#btnConnect');
  const btnPrintImage = $('#btnPrintImage');
  const btnDisconnect = $('#btnDisconnect');

  let device = null;
  let server = null;
  let writeCharacteristic = null;

  const KNOWN_SERVICES = [
    // Nordic UART Service (NUS)
    '6e400001-b5a3-f393-e0a9-e50e24dcca9e',
    // East-Asia BLE printers often use custom FFE0/FFE5
    0xffe0,
    0xffe5,
    // Some ESC/POS BLE bridges use 0x18F0/0x2AF1
    0x18f0,
    // Others vendor services can be discovered dynamically
  ];

  function concat(...chunks) {
    const total = chunks.reduce((n, c) => n + c.length, 0);
    const out = new Uint8Array(total);
    let off = 0;
    for (const c of chunks) { out.set(c, off); off += c.length; }
    return out;
  }

  function log(msg, cls='') {
    const p = document.createElement('div');
    p.textContent = msg;
    if (cls) p.classList.add(cls);
    logEl.appendChild(p);
    logEl.scrollTop = logEl.scrollHeight;
  }

  function supportsWebBluetooth() {
    return !!navigator.bluetooth;
  }

  async function connect() {
    if (!supportsWebBluetooth()) {
      log('Este navegador no soporta Web Bluetooth. Usa Chrome/Edge en Android/desktop y habilita Bluetooth.', 'err');
      return;
    }

    try {
      log('Mostrando selector de dispositivos‚Ä¶');
      const filters = [];

      device = await navigator.bluetooth.requestDevice({
        filters: undefined,
        acceptAllDevices: true,
        optionalServices: KNOWN_SERVICES
      });

      log(`Seleccionado: ${device.name || '(sin nombre)'}`, 'ok');

      device.addEventListener('gattserverdisconnected', () => {
        log('Desconectado', 'warn');
        btnDisconnect.disabled = true;
        btnPrintImage.disabled = true;
      });

      server = await device.gatt.connect();
      log('GATT conectado', 'ok');

      // Intentar servicios conocidos primero
      for (const svc of KNOWN_SERVICES) {
        try {
          const service = await server.getPrimaryService(svc);
          const characteristics = await service.getCharacteristics();
          for (const ch of characteristics) {
            if (ch.properties.write || ch.properties.writeWithoutResponse) {
              writeCharacteristic = ch;
              break;
            }
          }
          if (writeCharacteristic) break;
        } catch (e) { /* ignorar y seguir */ }
      }

      // Si no se encontr√≥, descubrir todos los servicios y elegir el primer characteristic con write
      if (!writeCharacteristic) {
        const services = await server.getPrimaryServices();
        for (const service of services) {
          const chs = await service.getCharacteristics();
          writeCharacteristic = chs.find(c => c.properties.write || c.properties.writeWithoutResponse) || null;
          if (writeCharacteristic) break;
        }
      }

      if (!writeCharacteristic) {
        throw new Error('No se encontr√≥ ning√∫n characteristic de escritura BLE. La impresora puede ser s√≥lo Bluetooth cl√°sico.');
      }

      log('Canal de escritura listo ‚úÖ', 'ok');
      btnDisconnect.disabled = false;
      btnPrintImage.disabled = false;
    } catch (err) {
      log('Error: ' + err.message, 'err');
      console.error(err);
    }
  }

  async function disconnect() {
    try {
      if (device && device.gatt.connected) {
        device.gatt.disconnect();
        log('Desconectado manualmente');
      }
    } catch (e) {
      log('Error al desconectar: ' + e.message, 'err');
    }
  }

  async function loadImageAsMonochrome(url, maxWidth = 384) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        // Escalar la imagen al ancho m√°ximo de la impresora
        const scale = Math.min(1, maxWidth / img.width);
        const width = Math.floor(img.width * scale);
        const height = Math.floor(img.height * scale);

        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        
        const imgData = ctx.getImageData(0, 0, width, height);
        const pixels = imgData.data;
        const mono = new Uint8Array(width * height);

        for (let i = 0; i < width * height; i++) {
          const r = pixels[i*4];
          const g = pixels[i*4+1];
          const b = pixels[i*4+2];
          const gray = 0.299*r + 0.587*g + 0.114*b;
          mono[i] = gray < 128 ? 1 : 0; // 1 = negro, 0 = blanco
        }
        resolve({mono, width, height});
      };
      img.onerror = reject;
      img.src = url;
    });
}

  function escposImage({mono, width, height}) {
    const ESC = 0x1B, GS = 0x1D;
    const bytesPerLine = Math.ceil(width / 8);
    const data = [];

    // comando: GS v 0
    data.push(GS, 0x76, 0x30, 0x00, bytesPerLine & 0xFF, (bytesPerLine >> 8) & 0xFF, height & 0xFF, (height >> 8) & 0xFF);

    for (let y = 0; y < height; y++) {
      for (let xByte = 0; xByte < bytesPerLine; xByte++) {
        let byte = 0;
        for (let bit = 0; bit < 8; bit++) {
          const x = xByte*8 + bit;
          if (x < width) {
            const pixel = mono[y*width + x];
            byte |= pixel ? (0x80 >> bit) : 0;
          }
        }
        data.push(byte);
      }
    }
    return new Uint8Array(data);
  }

  async function writeEscPos(data) {
    if (!writeCharacteristic) throw new Error('No hay characteristic de escritura');
      // Dividir en trozos para MTU (~180 bytes t√≠picos)
      const CHUNK = 180;
      for (let i = 0; i < data.length; i += CHUNK) {
        const slice = data.slice(i, i + CHUNK);
        try {
          // Preferir writeWithoutResponse si est√° disponible
          if (writeCharacteristic.properties && writeCharacteristic.properties.writeWithoutResponse) {
            await writeCharacteristic.writeValueWithoutResponse(slice);
          } else {
            await writeCharacteristic.writeValue(slice);
          }
        } catch (e) {
        // Algunos stacks requieren un peque√±o delay entre escrituras
        await new Promise(r => setTimeout(r, 30));
        if (writeCharacteristic.writeValue) await writeCharacteristic.writeValue(slice);
      }
      await new Promise(r => setTimeout(r, 10));
    }
  }
  
  async function printImage(url) {
    try {
      const imgData = await loadImageAsMonochrome(url);
      const escData = escposImage(imgData);

      const ESC = 0x1B;
      const init = new Uint8Array([ESC, 0x40]); // inicializar
      const feedCut = new Uint8Array([0x1D, 0x56, 0x41, 0x10]); // corte parcial

      const fullData = concat(init, escData, feedCut);
      await writeEscPos(fullData);
      log('Imagen enviada ‚úÖ', 'ok');
    } catch (e) {
      log('Error imprimiendo imagen: ' + e.message, 'err');
      console.error(e);
    }
  }

  async function imprimir() {
    printImage('https://raw.githubusercontent.com/yavuzceliker/sample-images/refs/heads/main/docs/image-1036.jpg');
  }

  btnConnect.addEventListener('click', connect);
  btnDisconnect.addEventListener('click', disconnect);
  btnPrintImage.addEventListener('click', imprimir);

  log("Aplicacion iniciada");
})();
</script>
</body>
</html>
